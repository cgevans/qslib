from __future__ import annotations
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import ClassVar, Iterable, Sequence
from . import parser
import pyparsing as pp
import textwrap
import xml.etree.ElementTree as ET
import uuid
from . import __version__


class XMLable(ABC):
    @abstractmethod
    def to_xml(self) -> ET.Element:
        ...


class ProtoCommand(ABC):
    @abstractmethod
    def to_command(self) -> str:
        ...


class BaseStep(ABC):
    @property
    @abstractmethod
    def body(self) -> Iterable[ProtoCommand]:
        ...

    @property
    @abstractmethod
    def identifier(self) -> int | str | None:
        ...

    @property
    @abstractmethod
    def repeat(self) -> int:
        ...

    def to_command(self, *, stepindex, **kwargs):
        s = "STEP "
        if self.repeat != 1:
            s += f"-repeat={self.repeat} "
        if self.identifier is not None:
            s += f"{self.identifier} "
        else:
            s += f"{stepindex} "
        s += "<multiline.step>\n"
        for com in self.body:
            s += f"\t{com.to_command(**kwargs)}\n"
        s += "</multiline.step>"
        return s


@dataclass
class Stage(XMLable):
    body: Iterable[BaseStep]
    repeat: int = 1
    index: int | None = None
    label: str | None = None

    def to_command(self, stageindex=None, **kwargs):
        s = "STAGe "
        if self.repeat != 1:
            s += f"-repeat={self.repeat} "
        if self.index is not None:
            s += f"{self.index} "
        else:
            s += f"{stageindex} "
        if self.label:
            s += self.label + " "
        else:
            s += f"STAGE_{self.index or stageindex} "
        s += "<multiline.stage>\n"
        for i, step in enumerate(self.body):
            s += textwrap.indent(f"{step.to_command(stepindex=i+1, **kwargs)}", "\t")
        s += "\n</multiline.stage>"
        return s

    @classmethod
    def from_xml(cls, e: ET.Element) -> Stage:
        raise NotImplementedError

    def to_xml(self) -> ET.Element:
        e = ET.Element("TCStage")
        ET.SubElement(e, "StageFlag").text = "QSLIB"
        ET.SubElement(e, "NumOfRepetitions").text = str(int(self.repeat))
        for s in self.body:
            assert isinstance(s, XMLable)
            e.append(s.to_xml())

        # TODO: StartingCycle, AutoDeltaEnabled

        return e


@dataclass
class Protocol(XMLable):
    stages: Iterable[Stage]
    name: str = field(default_factory=lambda: uuid.uuid1().hex)
    volume: float | None = None
    runmode: str | None = None
    filters: list[str] = field(default_factory=lambda: [])

    def to_command(self):
        s = "PROTocol "
        if self.volume is not None:
            s += f"-volume={self.volume} "
        if self.runmode is not None:
            s += f"-runmode={self.runmode} "
        s += self.name + " "
        s += "<quote.message>\n"
        for i, stage in enumerate(self.stages):
            s += (
                textwrap.indent(
                    stage.to_command(filters=self.filters, stageindex=i + 1), "\t"
                )
                + "\n"
            )
        s += "</quote.message>"
        return s

    @classmethod
    def from_xml(cls, e: ET.Element) -> Protocol:
        raise NotImplementedError

    def to_xml(self) -> ET.Element:
        e = ET.Element("TCProtocol")
        ET.SubElement(e, "FileVersion").text = "2.0"
        ET.SubElement(e, "ProtocolName").text = self.name
        ET.SubElement(e, "QSLibNote").text = (
            "This protocol was"
            " generated by QSLib. It may be only an approximation or"
            " placeholder for the real protocol, contained as"
            " an SCPI command in QSLibProtocolCommand."
        )
        ET.SubElement(e, "QSLibProtocolCommand").text = self.to_command()
        ET.SubElement(e, "QSLibVerson").text = __version__
        if self.volume is not None:
            ET.SubElement(e, "SampleVolume").text = str(self.volume)
        if self.runmode is not None:
            ET.SubElement(e, "RunMode").text = str(self.runmode)
        return e


@dataclass
class Ramp(ProtoCommand):
    temperature: Sequence[float]
    increment: float | None = None
    incrementcycle: int | None = None
    incrementstep: int | None = None
    rate: float | None = None
    cover: float | None = None
    _argfields: ClassVar[tuple[str, ...]] = (
        "increment",
        "incrementcycle",
        "incrementstep",
        "rate",
        "cover",
    )

    def to_command(self, **kwargs) -> str:
        p = []
        p.append("RAMP")
        for f in self._argfields:
            if (v := getattr(self, f)) is not None:
                p.append(f"-{f}={v}")
        p += self.temperature
        return " ".join(str(x) for x in p)

    @classmethod
    def parser(cls):
        return parser.command_onearg(cls, "RAMP")


@dataclass
class HACFILT(ProtoCommand):
    filters: Sequence[str] | None

    def to_command(self, filters=None, **kwargs) -> str:
        if self.filters is None:
            filters = filters
        else:
            filters = self.filters
        return "HACFILT " + " ".join(filters)

    @classmethod
    def parser(cls):
        return (
            pp.Keyword("HACFILT").suppress()
            + parser.we
            + pp.delimitedList(
                pp.delimitedList(pp.Word(pp.alphanums), combine=True), pp.White(" ")
            )
        ).setParseAction(lambda tok: cls([x for x in tok]))


@dataclass
class HoldAndCollect(ProtoCommand):
    time: int
    increment: float | None = None
    incrementcycle: int | None = None
    incrementstep: int | None = None
    tiff: bool = False
    quant: bool = True
    pcr: bool = False
    _argfields: ClassVar[tuple[str, ...]] = (
        "increment",
        "incrementcycle",
        "incrementstep",
        "tiff",
        "quant",
        "pcr",
    )

    def to_command(self, **kwargs) -> str:
        p = []
        p.append("HoldAndCollect")
        for f in self._argfields:
            if (v := getattr(self, f)) is not None:
                p.append(f"-{f}={v}")
        p.append(self.time)
        return " ".join(str(x) for x in p)

    @classmethod
    def parser(cls):
        return parser.command_args(cls, "HoldAndCollect")


@dataclass
class Step(BaseStep, XMLable):
    time: int
    temperature: float | Sequence[float]
    temp_increment: float | None = None
    temp_increment_cycle: int | None = None
    time_increment: float | None = None
    time_increment_cycle: int | None = None
    filters = None
    pcr = False
    quant = True
    tiff = False

    @property
    def repeat(self) -> int:
        return 1

    @property
    def identifier(self) -> None:
        return None

    @property
    def temperature_list(self) -> list[float]:
        if isinstance(self.temperature, Sequence):
            return list(self.temperature)
        else:
            return 6 * [self.temperature]

    @property
    def body(self) -> list[ProtoCommand]:
        if isinstance(self.temperature, float):
            t = [self.temperature] * 6
        else:
            t = self.temperature
        return [
            Ramp(t, self.temp_increment, self.temp_increment_cycle),
            HACFILT(self.filters),
            HoldAndCollect(
                self.time,
                self.time_increment,
                self.time_increment_cycle,
                None,
                self.tiff,
                self.quant,
                self.pcr,
            ),
        ]

    @classmethod
    def from_xml(cls, e: ET.Element) -> Step:
        raise NotImplementedError

    def to_xml(self) -> ET.Element:
        e = ET.Element("TCStep")
        ET.SubElement(e, "CollectionFlag").text = str(int(self.quant))
        for t in self.temperature_list:
            ET.SubElement(e, "Temperature").text = str(t)
        ET.SubElement(e, "HoldTime").text = str(self.time)
        if self.temp_increment:
            ET.SubElement(e, "ExtTemperature").text = str(self.temp_increment)
        if self.time_increment:
            ET.SubElement(e, "ExtHoldTime").text = str(self.time_increment)
        # TODE: RampRate, RampRateUnit
        return e
